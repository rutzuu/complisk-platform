---
alwaysApply: true
---

# Z0 Blog Template - Development Guidelines

## Code Style and Structure

- Write concise, technical TypeScript code with accurate examples.
- Use functional and declarative programming patterns; avoid classes.
- Favor iteration and modularization over code duplication.
- Use descriptive variable names with auxiliary verbs (e.g., `isLoading`, `hasError`).
- Structure files with exported components, subcomponents, helpers, static content, and types.
- Use lowercase with dashes for directory names (e.g., `components/blog-section`).
- Never add inline comments unless instructed.

## Project Structure

```
z0-blog-template/
â”œâ”€â”€ ğŸ”§ Configuration Files
â”œâ”€â”€ ğŸ“± App Directory (Next.js App Router)
â”œâ”€â”€ âš¡ Actions (Server Actions)
â”œâ”€â”€ ğŸ—ï¸ Collections (Payload CMS)
â”œâ”€â”€ ğŸ§© Components (React Components)
â”œâ”€â”€ ğŸ“Š Data (Static Data - Optional)
â”œâ”€â”€ ğŸª Hooks (Custom React Hooks)
â”œâ”€â”€ ğŸ› ï¸ Lib (Utilities & Configurations)
â”œâ”€â”€ ğŸ“ Media (Payload CMS Uploads)
â”œâ”€â”€ ğŸŒ Public (Static Assets)
â””â”€â”€ ğŸ·ï¸ Types (TypeScript Definitions)
```

## Directory Organization

### ğŸ”§ Root Configuration Files

```
z0-blog-template/
â”œâ”€â”€ package.json                 # Dependencies and scripts
â”œâ”€â”€ tsconfig.json               # TypeScript configuration
â”œâ”€â”€ next.config.ts              # Next.js configuration
â”œâ”€â”€ payload.config.ts           # Payload CMS configuration
â”œâ”€â”€ components.json             # Shadcn/ui configuration
â”œâ”€â”€ eslint.config.mjs          # ESLint configuration
â”œâ”€â”€ postcss.config.mjs         # PostCSS configuration
â”œâ”€â”€ next-env.d.ts              # Next.js type definitions
â”œâ”€â”€ payload-types.ts           # Auto-generated Payload types
â””â”€â”€ .env.local                 # Environment variables (not in git)
```

### ğŸ“± App Directory (`/app`)

Following Next.js 15 App Router structure with route groups:

```
app/
â”œâ”€â”€ (frontend)/                 # Public-facing routes
â”‚   â”œâ”€â”€ layout.tsx             # Frontend layout with navbar
â”‚   â”œâ”€â”€ page.tsx               # Homepage
â”‚   â”œâ”€â”€ globals.css            # Global styles
â”‚   â””â”€â”€ blog/
â”‚       â”œâ”€â”€ page.tsx           # Blog listing page
â”‚       â””â”€â”€ [slug]/
â”‚           â””â”€â”€ page.tsx       # Individual blog post
â””â”€â”€ (payload)/                 # Payload CMS admin routes
    â”œâ”€â”€ layout.tsx             # Admin layout
    â”œâ”€â”€ custom.scss            # Admin custom styles
    â”œâ”€â”€ admin/
    â”‚   â”œâ”€â”€ importMap.js       # Payload import map
    â”‚   â””â”€â”€ [[...segments]]/
    â”‚       â”œâ”€â”€ page.tsx       # Admin pages
    â”‚       â””â”€â”€ not-found.tsx  # Admin 404
    â””â”€â”€ api/
        â”œâ”€â”€ [...slug]/
        â”‚   â””â”€â”€ route.ts       # Payload API routes
        â”œâ”€â”€ graphql/
        â”‚   â””â”€â”€ route.ts       # GraphQL endpoint
        â””â”€â”€ graphql-playground/
            â””â”€â”€ route.ts       # GraphQL playground
â”œâ”€â”€ robots.ts                  # SEO robots.txt
â””â”€â”€ sitemap.ts                 # Dynamic sitemap generation
```

### âš¡ Actions Directory (`/actions`)

Server Actions for data fetching and mutations:

```
actions/
â””â”€â”€ blog.ts                    # Blog-related server actions
```

**Function patterns:**
- `getFeaturedBlog()` - Fetch featured blog post
- `getBlogPosts()` - Fetch non-featured blog posts
- `getAllBlogPosts(limit?)` - Fetch all posts with optional limit
- `getBlogPostBySlug(slug)` - Fetch specific post by slug
- `getPaginatedBlogPosts()` - Fetch paginated posts
- `getBlogPostsByCategory(category)` - Fetch posts by category

### ğŸ—ï¸ Collections Directory (`/collections`)

Payload CMS collection definitions:

```
collections/
â”œâ”€â”€ Media.ts                   # Media/file uploads collection
â”œâ”€â”€ Posts.ts                   # Blog posts collection
â”œâ”€â”€ Template.ts                # Email templates collection
â”œâ”€â”€ Users.ts                   # User management collection
â”œâ”€â”€ Pages.ts                   # Example: Static pages (optional)
â””â”€â”€ Services.ts                # Example: Services collection (optional)
```

### ğŸ§© Components Directory (`/components`)

React components organized by feature:

```
components/
â”œâ”€â”€ ui/                        # Shadcn/ui components
â”‚   â”œâ”€â”€ button.tsx
â”‚   â”œâ”€â”€ card.tsx
â”‚   â”œâ”€â”€ badge.tsx
â”‚   â””â”€â”€ ... (other shadcn components)
â”œâ”€â”€ blog/                      # Blog-specific components
â”‚   â””â”€â”€ blogs-section.tsx
â”œâ”€â”€ hero-section.tsx           # Homepage hero
â”œâ”€â”€ navbar.tsx                 # Navigation component
â””â”€â”€ tailwind-indicator.tsx     # Dev environment indicator
```

### ğŸ“Š Data Directory (`/data` - Optional)

Static data and configuration:

```
data/
â”œâ”€â”€ navigation.ts              # Navigation menu items
â”œâ”€â”€ site-config.ts            # Site configuration
â””â”€â”€ ... (other static data)
```

### ğŸª Hooks Directory (`/hooks`)

Custom React hooks:

```
hooks/
â”œâ”€â”€ use-mobile.ts              # Mobile detection hook
â””â”€â”€ ... (other custom hooks)
```

### ğŸ› ï¸ Lib Directory (`/lib`)

Utilities, configurations, and helper functions:

```
lib/
â”œâ”€â”€ utils.ts                   # General utility functions (cn, etc.)
â”œâ”€â”€ payload.ts                 # Payload CMS client configuration
â””â”€â”€ metadata.ts                # SEO metadata generation utilities
```

### ğŸ·ï¸ Types Directory (`/types`)

TypeScript type definitions:

```
types/
â”œâ”€â”€ blog.ts                    # Blog-related types
â””â”€â”€ ... (other type definitions)
```

### ğŸŒ Public Directory (`/public`)

Static assets:

```
public/
â”œâ”€â”€ images/
â”œâ”€â”€ icons/
â””â”€â”€ ... (other static files)
```

## Organization Principles

### 1. Feature-First Organization

- Group related files by feature/domain
- Keep components close to where they're used
- Example: All blog-related components in `/components/blog/`

### 2. Separation of Concerns

- **Actions**: Server-side data operations
- **Components**: UI presentation layer
- **Hooks**: Reusable stateful logic
- **Lib**: Pure utility functions
- **Types**: Type definitions

### 3. Consistent Naming Conventions

- **Directories**: lowercase with dashes (`blog-components/`)
- **Files**: lowercase with dashes (`hero-section.tsx`)
- **Components**: PascalCase (`HeroSection`)
- **Functions**: camelCase (`getBlogPosts`)

### 4. Import Path Organization

```typescript
// External libraries first
import React from 'react'
import { Button } from '@/components/ui/button'

// Internal imports by proximity
import { getBlogPosts } from '@/actions/blog'
import { BlogCard } from '@/components/blog/blog-card'
import type { BlogPost } from '@/types/blog'
```

## Best Practices by Directory

### Server Actions (`/actions`)

- Use `'use server'` directive at the top
- Handle errors gracefully with try-catch
- Return serializable data only
- Follow naming convention: `getX`, `createX`, `updateX`, `deleteX`
- Always type return values

```typescript
'use server'

import { payload } from '@/lib/payload'
import type { BlogPost } from '@/types/blog'

export async function getBlogPosts(): Promise<BlogPost[]> {
  try {
    const result = await payload.find({
      collection: 'posts',
      sort: '-createdAt',
    })
    return result.docs as unknown as BlogPost[]
  } catch (error) {
    console.error('Error fetching blog posts:', error)
    return []
  }
}
```

### Components (`/components`)

- Keep components small and focused
- Use TypeScript interfaces for props
- Implement proper error boundaries
- Follow accessibility guidelines
- Prefer Server Components over Client Components

```typescript
interface HeroSectionProps {
  title: string
  description?: string
}

export function HeroSection({ title, description }: HeroSectionProps) {
  return (
    <section className="container">
      <h1>{title}</h1>
      {description && <p>{description}</p>}
    </section>
  )
}
```

### Types (`/types`)

- Export types from specific domain files
- Use descriptive names
- Leverage TypeScript utility types
- Keep types close to their usage

```typescript
export type BlogPost = {
  id: string | number
  title: string
  slug: string
  content: any
}

export type FeaturedBlog = BlogPost
```

### Hooks (`/hooks`)

- Start with `use` prefix
- Return objects for multiple values
- Handle cleanup in useEffect
- Make them reusable and testable

```typescript
export function useMobile() {
  const [isMobile, setIsMobile] = useState(false)
  
  useEffect(() => {
    // Implementation
  }, [])
  
  return isMobile
}
```

### Collections (`/collections`)

- Use clear field names and descriptions
- Implement proper validation
- Add admin descriptions for editors
- Use hooks for auto-generation (slugs, etc.)

```typescript
export const Posts: CollectionConfig = {
  slug: 'posts',
  admin: {
    useAsTitle: 'title',
  },
  fields: [
    {
      name: 'title',
      type: 'text',
      required: true,
    },
    // ... other fields
  ],
}
```

## Payload CMS Patterns

- Structure collections with clear relationships and field validation
- Implement proper access control with field-level permissions
- Create reusable field groups and blocks for content modeling
- Follow the Payload hooks pattern for extending functionality
- Use migrations for database schema changes
- Organize collections by domain or feature
- Implement proper upload handling with Vercel Blob storage

## SEO Best Practices

- Use `generateMetadata` from `lib/metadata.ts` for all pages
- Implement dynamic metadata for blog posts
- Create proper OpenGraph images
- Use structured data (JSON-LD) where appropriate
- Maintain `robots.ts` and `sitemap.ts` files
- Add proper meta descriptions and titles

## Storage Configuration

The template supports both local storage and Vercel Blob storage:

- **Local**: Files stored in `/media` directory (default)
- **Vercel Blob**: Cloud storage when `BLOB_READ_WRITE_TOKEN` is set
- Configuration is automatic based on environment variables

## Extending the Template

### Adding a New Collection

1. Create a new file in `/collections` (e.g., `Events.ts`)
2. Define your collection schema
3. Import it in `payload.config.ts`
4. Add it to the collections array
5. Create corresponding types in `/types`
6. Create server actions in `/actions`

### Adding a New Page

1. Create a new route in `app/(frontend)`
2. Export metadata using `generateMetadata`
3. Fetch data using server actions
4. Add route to `sitemap.ts` if needed

### Adding Custom Fields

Refer to example collections (`Pages.ts`, `Services.ts`) for patterns on:
- Text fields
- Rich text (Lexical)
- Upload fields
- Select fields
- Group fields
- Array fields

## TypeScript Usage

- Use TypeScript for all code; prefer interfaces over types
- Avoid enums; use string unions instead
- Use functional components with TypeScript interfaces
- Leverage Payload's auto-generated types

## Error Handling and Validation

- Prioritize error handling: handle errors and edge cases early
- Use early returns and guard clauses
- Implement proper error logging
- Use Zod for form validation when needed
- Model expected errors as return values in Server Actions

## UI and Styling

- Use Shadcn UI components for consistency
- Implement responsive design with Tailwind CSS
- Use a mobile-first approach
- Follow the existing design system

## Performance Optimization

- Minimize `'use client'` usage
- Favor React Server Components (RSC)
- Use dynamic loading for non-critical components
- Optimize images: use proper formats and lazy loading
- Implement proper caching strategies

## Key Conventions

- Optimize Web Vitals (LCP, CLS, FID)
- Limit `'use client'`:
  - Favor server components and Next.js SSR
  - Use only for Web API access in small components
  - Avoid for data fetching or state management

Follow Next.js docs for Data Fetching, Rendering, and Routing.
